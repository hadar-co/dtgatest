name: Weekly Kapa Usage Report

on:
#   schedule:
#     # Runs at 9:00 AM UTC every Monday
#     - cron: '0 9 * * 1'
  workflow_dispatch:  # Allows manual triggering

jobs:
  generate-and-send-report:
    runs-on: ubuntu-latest
    steps:
      - name: Get Current Date
        id: date
        run: |
          echo "start_date=$(date -d '7 days ago' -u +%Y-%m-%dT00:00:00Z)" >> $GITHUB_ENV
          echo "end_date=$(date -u +%Y-%m-%dT23:59:59Z)" >> $GITHUB_ENV

      - name: Fetch Kapa Analytics
        id: fetch-analytics
        run: |
          # Make the API call and store response directly to file
          curl -v -s -X GET \
            "https://api.kapa.ai/query/v1/projects/e64464bc-19b5-4cd2-9779-2930e2ca0b81/analytics/activity/?start_date_time=${{ env.start_date }}&end_date_time=${{ env.end_date }}&aggregation_period=DAY" \
            -H "X-API-KEY: ${{ secrets.KAPA_API_KEY }}" \
            -o kapa_response.json
          
          # Debug: Print the first part of the response
          echo "API Response (first 500 chars):"
          head -c 500 kapa_response.json
          
          # Validate JSON response
          if ! jq empty kapa_response.json; then
            echo "Error: Invalid JSON response from API"
            echo "Full response:"
            cat kapa_response.json
            exit 1
          fi
          
          # Verify the response has the expected structure
          if ! jq -e '.aggregate_statistics' kapa_response.json > /dev/null; then
            echo "Error: Response missing aggregate_statistics"
            echo "Response structure:"
            jq '.' kapa_response.json
            exit 1
          fi
          
          if ! jq -e '.time_series' kapa_response.json > /dev/null; then
            echo "Error: Response missing time_series"
            echo "Response structure:"
            jq '.' kapa_response.json
            exit 1
          fi
          
          # Create JSON payload for Slack
          cat << EOF > slack_payload.json
          {
            "text": "Weekly Kapa.ai Usage Report",
            "blocks": [
              {
                "type": "header",
                "text": {
                  "type": "plain_text",
                  "text": "ðŸ“Š Weekly Kapa.ai Usage Report",
                  "emoji": true
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "Period: $(date -d '${{ env.start_date }}' '+%B %d') - $(date -d '${{ env.end_date }}' '+%B %d, %Y')"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Key Metrics:*\nâ€¢ Total Questions: $(jq -r '.aggregate_statistics.total_questions' kapa_response.json)\nâ€¢ Unique Users: $(jq -r '.aggregate_statistics.total_unique_users' kapa_response.json)\nâ€¢ Support Tickets Deflected: $(jq -r '.aggregate_statistics.total_support_tickets_deflected' kapa_response.json)"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Quality Metrics:*\nâ€¢ Upvotes: $(jq -r '.aggregate_statistics.total_upvotes' kapa_response.json)\nâ€¢ Downvotes: $(jq -r '.aggregate_statistics.total_downvotes' kapa_response.json)\nâ€¢ Uncertain Responses: $(jq -r '.aggregate_statistics.total_questions_uncertain' kapa_response.json)"
                }
              }
            ]
          }
          EOF

          # Add success rate if there are votes
          total_votes=$(jq -r '.aggregate_statistics.total_upvotes + .aggregate_statistics.total_downvotes' kapa_response.json)
          if [ "$total_votes" -gt 0 ]; then
            success_rate=$(echo "scale=1; $(jq -r '.aggregate_statistics.total_upvotes' kapa_response.json) * 100 / $total_votes" | bc)
            jq --arg rate "$success_rate" '.blocks += [{"type": "section", "text": {"type": "mrkdwn", "text": "*Success Rate:* \($rate)%"}}]' slack_payload.json > temp.json && mv temp.json slack_payload.json
          fi

          # Add integration breakdown
          echo "Adding integration stats..."
          integration_stats=$(jq -r '
            .time_series | 
            map(.count_by_integration[]) | 
            group_by(.integration_type) | 
            map({
              type: .[0].integration_type,
              description: .[0].description,
              total: map(.count) | add
            }) |
            sort_by(.total) |
            reverse[] |
            select(.total > 0) |
            "â€¢ \(.description // .type): \(.total)"
          ' kapa_response.json | paste -sd "\n" -)

          if [ ! -z "$integration_stats" ]; then
            jq --arg stats "$integration_stats" '.blocks += [{"type": "section", "text": {"type": "mrkdwn", "text": "*Questions by Integration:*\n\($stats)"}}]' slack_payload.json > temp.json && mv temp.json slack_payload.json
          fi

          # Store the payload for the Slack step
          echo "slack_payload<<EOF" >> $GITHUB_ENV
          cat slack_payload.json >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Send to Slack
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: ${{ env.slack_payload }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }} 
